apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: network-stack-definition
spec:
  schema:
    apiVersion: v1alpha1
    kind: NetworkStack
    spec:
        name: string
        domain: string
        email: string

        production: boolean | false

        # ingress:
        #   enabled: boolean | default=true
        #   domain: string | default="example.com"
        #   subdomain: string | default="app"
        #   tls: boolean | default=false

        ingress:
          class: string |  default="traefik"

        dns:
          token: string
          duckdns: boolean | default=false
          cloudflare: boolean | default=false
          dynamicDns: boolean | default=true

    # status:
    #   # Fields the controller will inject into instances status.
    #   certManagerConditions: ${certmanager.status.conditions}

#  validation:
#     # Validating admission policies added to the new API type's CRD
#     - expression: "${ self.image == 'nginx' || !self.ingress.enabled }"
#       message: "Only nginx based applications can have ingress enabled"

  # Define the resources this API will manage.
  resources:
      - id: certmanager
        includeWhen:
          - ${schema.spec.dns.duckdns || schema.spec.dns.cloudflare} # Only include if the user wants to use DuckDNS or Cloudflare
        template:
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: cert-manager
              namespace: argocd
              annotations:
                argocd.argoproj.io/sync-wave: "-10"
                
              finalizers:
                - resources-finalizer.argocd.argoproj.io

            spec:
              project: default

              syncPolicy:
                automated:
                  selfHeal: true
                  prune: true
                  allowEmpty: true
              
                syncOptions:
                  - CreateNamespace=true
                  # - ApplyOutOfSyncOnly=true

              destination:
                server: https://kubernetes.default.svc
                namespace: cert-manager

              source:
                repoURL: https://charts.jetstack.io
                chart: cert-manager  
                targetRevision: 1.17.1
                helm:
                  valuesObject:
                    crds:
                      enabled: true
                      keep: false
       

  
      - id: certManagerWebhookDuckdnsHelmChart
        includeWhen:
          - ${schema.spec.dns.duckdns} # Only include if the user wants to use DuckDNS
        # readyWhen:
        #   - ${certManagerHelmChart.status.conditions} # Ensure cert-manager is ready before deploying the webhook
        template:
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: cert-manager-duckdns-webhook
              namespace: argocd
              annotations:
                argocd.argoproj.io/sync-wave: "-8"
                
              finalizers:
                - resources-finalizer.argocd.argoproj.io

            spec:
              project: default

              syncPolicy:
                automated:
                  selfHeal: true
                  prune: true
                  allowEmpty: true
              
                syncOptions:
                  - CreateNamespace=true
                  # - ApplyOutOfSyncOnly=true

              destination:
                server: https://kubernetes.default.svc
                namespace: cert-manager

              source:
                repoURL: https://csp33.github.io/cert-manager-duckdns-webhook
                chart: cert-manager-duckdns-webhook  
                targetRevision: 1.1.3
                helm:
                  valuesObject:
                    crds:
                      enabled: true
                      keep: false

                    token:
                      value: ${schema.spec.dns.token}
                
                    clusterIssuer:
                      email: ${schema.spec.email}
                      staging:
                        create: true
                        name: lets-encrypt-acme-issuer-staging
                      production:
                        create: ${schema.spec.production}
                        name: lets-encrypt-acme-issuer-production 
            

      - id: duckdnsddns 
        includeWhen:
          - ${schema.spec.dns.dynamicDns} # Only include if the user wants to use dynamic DNS
        template:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: duckdns-ddns
            namespace: argocd
            annotations:
              argocd.argoproj.io/sync-wave: "-10"
              
            finalizers:
              - resources-finalizer.argocd.argoproj.io

          spec:
            project: default

            syncPolicy:
              automated:
                selfHeal: true
                prune: true
                allowEmpty: true
            
              syncOptions:
                - CreateNamespace=true
                # - ApplyOutOfSyncOnly=true

            destination:
              server: https://kubernetes.default.svc
              namespace: duckdns-ddns

            source:
              repoURL: git@github.com:rbellius/charts.git
              path: duckdns-ddns
              targetRevision: main
              helm:
                valuesObject:
                  duckdns:
                    domain: ${schema.spec.domain}
                    token: ${schema.spec.dns.token}

# ---
# apiVersion: kro.run/v1alpha1
# kind: NetworkStack
# metadata:
#   name: mobile-network-stack
# spec:
#     name: MobileFreeNetworkStack
#     domain: demo-123.duckdns.org
#     email: eddie.moya@gmail.com

#     production: false

#     ingress:
#       class: traefik

#     dns:
#       token: 8f0446f9-7cb7-4412-a6ce-a51036614a17
#       duckdns: true
#       cloudflare: false
#       dynamicDns: true
