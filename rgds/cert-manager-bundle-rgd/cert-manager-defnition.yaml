apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: cert-manager-bundle
  labels:
    app.kubernetes.io/name: cert-manager-bundle-rgd
    app.kubernetes.io/instance: cert-manager-bundle
    app.kubernetes.io/component: rgd
    app.kubernetes.io/part-of: mikrolab
  annotations:
    argocd.argoproj.io/instance: cert-manager-bundle

  finalizers:
    - resources-finalizer.argocd.argoproj.io/foreground
spec:
  schema:
    apiVersion: v1alpha1
    kind: CertManagerBundle
    spec:

        env: string | default="staging" enum="staging,production"

        ingress:
          class: string | default="traefik" enum="traefik"
          requests: boolean | default=true

        dns:
          providers: 
            # cloudflare:
            #   enabled: boolean | default=false
            #   email: string
            #   domain: string 
            duckdns:
              enabled: boolean | default=true
              email: string
              domain: string
              dynamic: boolean | default=true
            builtin:
              enabled: boolean | default=false
              dynamic: boolean | default=false # No dynamic DNS for builtin providers yet
              provider: string | default="cloudflare" enum="cloudflare" # cloudflare is the only builtin provider for now
              email: string 
              domain: string
            default: 
              provider: string | default="duckdns" enum="duckdns,builtin" # Default provider to use if none is specified
              domain: string  # Default domain to use if none is specified

    status:
      certmanager:
        resources: ${certmanager.status.operationState.syncResult.resources}
        healthy: ${certmanager.status.health.status}
        synced: ${certmanager.status.sync.status}  
    


    # status:
        
    #     clusterIssuerCRDStatus: ${clusterIssuerCrd.status.state == "ACTIVE"} # The status of the ClusterIssuer CRD that cert-manager uses to create ClusterIssuers.
    #     certManagerStatus: ${certmanager.status.state}
        # ingressConfigGenerator: ${ingressConfigGenerator.status.conditions} # The status of the ingress configmap that will be used by the ingress-request controller to manage ingress requests.
    #   # Fields the controller will inject into instances status.
    #   certManagerConditions: ${certmanager.status.conditions}

#  validation:
#     # Validating admission policies added to the new API type's CRD
#     - expression: "${ self.image == 'nginx' || !self.ingress.enabled }"
#       message: "Only nginx based applications can have ingress enabled"

  # Define the resources this API will manage.
  resources:
      # - id: certManagerArgofile
      #   readyWhen:
      #     - ${certManagerArgofile.applicationsReady == "true"}
      #     # - ${certManagerArgofile.status.sync.status == "Synced"}
      #     # - ${certManagerArgofile.status.health.status == "Healthy"}
      #   template:
      #     apiVersion: kro.run/v1alpha1
      #     kind: Argofile
      #     metadata:
      #       name: platform-argofile
      #       namespace: platform
      #     spec:
      #       applications:
      #       - name: cert-manager
      #         enabled: true  
      #         hook: PreSync
      #         destination:
      #           namespace: cert-manager
      #         source:
      #           repoURL: https://charts.jetstack.io
      #           chart: cert-manager  

      - id: ingressConfigGenerator
        includeWhen:
          - ${schema.spec.ingress.requests} # Only include if the user wants to use ingress requests
          # - ${certManager.status.conditions} # Ensure cert-manager is ready before creating the configmap
        # readyWhen:
        #   - ${ingressConfigGenerator.status.state == "Ready"} # Ensure the configmap is created before using it"
        template:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: ingress-request-configmap
            namespace: cert-manager
            annotations:
         
              argocd.argoproj.io/instance: cert-manager-bundle
              # argocd.argoproj.io/hook: PreSync
            finalizers:
                - resources-finalizer.argocd.argoproj.io/foreground
              # argocd.argoproj.io/sync-wave: "0"
            labels:
              app.kubernetes.io/instance:   cert-manager-bundle
              app.kubernetes.io/name:       ingress-request-configmap
              app.kubernetes.io/part-of:    mikrolab

          data:
            # This is the configmap that will be used by the ingress-request controllerto manage ingress requests.
            # It is used to configure the ingress class and the default domain.
            ingressClass:   ${schema.spec.ingress.class}
            domain:         ${schema.spec.dns.providers.default.domain}
            clusterIssuer:  ${schema.spec.dns.providers.default.provider}-letsencrypt-${schema.spec.env} # This is the cluster issuer that will be used by the ingress-request controller to issue certificates for the ingress requests.

      # - id: certManagerChart
      #   template:
      #     apiVersion: kro.run/v1alpha1
      #     kind: Argofile
      #     metadata:
      #       name: platform-argofile
      #       namespace: platform
      #     spec:
      #       appType: Application
      #       application:
      #           name: cert-manager-chart
      #           enabled: true  
      #           hook: PreSync
      #           destination:
      #             namespace: cert-manager
      #           source:
      #             repoURL: https://charts.jetstack.io
      #             targetRevision: 1.17.2
      #             chart: cert-manager

      - id: certmanager
        template:
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: cert-manager
              namespace: argocd
              annotations:
                argocd.argoproj.io/instance: cert-manager-bundle
                # argocd.argoproj.io/hook: PreSync
                # argocd.argoproj.io/sync-wave: "-10"              
      
              finalizers:
                - resources-finalizer.argocd.argoproj.io/foreground

            spec:

              project: default 
              
              syncPolicy:
                automated:
                  selfHeal: true
              
                syncOptions:
                  - CreateNamespace=true
                  # - ApplyOutOfSyncOnly=true

              destination:
                server: https://kubernetes.default.svc
                namespace: cert-manager

              source:
                repoURL: https://charts.jetstack.io
                chart: cert-manager  
                targetRevision: 1.17.2
                helm:
                  valuesObject:
                    crds:
                      enabled: true
                      keep: false
                      
                    enableCertificateOwnerRef: true
                    extraArgs:
                      - --dns01-recursive-nameservers-only
                      - --dns01-recursive-nameservers=1.1.1.1:53,8.8.8.8:53
        


        # ${clustreIssuerCrd.status.conditions.exists(x, x.type == 'Established' && x.status == "True")}

      # - id: clusterIssuerCrd
      #   readyWhen:
      #     - ${certmanager.status.state == "ACTIVE" && clusterIssuerCrds.status.conditions.exists(x, x.type == 'Established' && x.status == "True")} # Ensure cert-manager is ready before deploying the issuer  
      #   template:
      #     apiVersion: apiextensions.k8s.io/v1
      #     kind: CustomResourceDefinition
      #     metadata:
      #       name: clusterissuers.cert-manager.io


      # - id: certManagerBuiltInIssuer
      #   includeWhen:
      #     - ${certmanager.status.state == "ACTIVE" && clusterIssuerCrds.status.conditions.exists(x, x.type == 'Established' && x.status == "True")} ## Ensure cert-manager is ready before deploying the issuer
      #   # includeWhen:
      #     # - ${schema.spec.dns.providers.builtin.enabled} # Only include if the user wants to use Cloudflare
      #   template:
      #     apiVersion: cert-manager.io/v1
      #     kind: ${clusterIsssuerCrd.kind}

      #     metadata:
      #       name: ${schema.spec.dns.providers.builtin.provider}-letsencrypt-${schema.spec.env}
      #       annotations:
      #         # argocd.argoproj.io/hook: PostSync
      #         # argocd.argoproj.io/sync-wave: "10"
      #         argocd.argoproj.io/instance: cert-manager-${schema.spec.dns.providers.builtin.provider}
      #         rbellius.com/cert-manager-condition: ${certmanager.status.?state}
      #       finalizers:
      #         - resources-finalizer.argocd.argoproj.io/foreground

      #       labels:
      #         app.kubernetes.io/instance: 'cert-manager'
      #         app.kubernetes.io/component: '${schema.spec.dns.providers.builtin.provider}-issuer-${schema.spec.env}'
      #         app.kubernetes.io/name: cert-manager-${schema.spec.dns.providers.builtin.provider}-issuer-${schema.spec.env}
      #         app.kubernetes.io/part-of: cert-manager
      #     spec:
      #       acme:

      #         # Email address used for ACME registration
      #         email: ${schema.spec.dns.providers.builtin.email}

      #         # Let's Encrypt Staging
      #         server: https://acme-staging-v02.api.letsencrypt.org/directory

      #         # Let's Encrypt Production
      #         # server: https://acme-v02.api.letsencrypt.org/directory


      #         privateKeySecretRef:
      #           name: issuer-account-key

      #         solvers:

      #         # DNS01 challenge
      #         - dns01:

      #             # Cloudflare DNS01 challenge provider
      #             # ${schema.spec.dns.providers.builtin.provider}:
      #             cloudflare:

      #               # Cloudflare acccount email
      #               email: ${schema.spec.dns.providers.builtin.email}

      #               # Cloudflare Orgin CA API Token
      #               apiKeySecretRef:
      #                 name: '${schema.spec.dns.providers.builtin.provider}-api-key-secret'
      #                 key: '${schema.spec.dns.providers.builtin.provider}'
      #           selector:
      #             dnsZones:
      #             - '${schema.spec.dns.providers.builtin.domain}'





      - id: certManagerBuiltInProvider
        includeWhen:
          - ${schema.spec.dns.providers.builtin.enabled} # Only cloudflare is supported for now
        template:
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: 'cert-manager-${schema.spec.dns.providers.builtin.provider}'
              namespace: argocd
              annotations:
                argocd.argoproj.io/instance: cert-manager-bundle
                # argocd.argoproj.io/sync-wave: "-10" 
                # argocd.argoproj.io/hook: "PreSync"             
      
              finalizers:
                - resources-finalizer.argocd.argoproj.io
              labels:
                    app.kubernetes.io/name:       'cert-manager-${schema.spec.dns.providers.builtin.provider}-application'
                    app.kubernetes.io/instance:   'cert-manager-bundle'
                    app.kubernetes.io/component:  'cert-manager-${schema.spec.dns.providers.builtin.provider}-webhook'
                    app.kubernetes.io/part-of:    'mikrolab'
            spec:
              project: default

              syncPolicy:
                automated:
                  selfHeal: true
                  prune: true
                  allowEmpty: true
              
                syncOptions:
                  - CreateNamespace=true
                  # - ApplyOutOfSyncOnly=true

              destination:
                server: https://kubernetes.default.svc
                namespace: cert-manager

              source:
                repoURL: git@github.com:rbellius/charts.git
                path: 'cert-manager-${schema.spec.dns.providers.builtin.provider}'
                targetRevision: main
                helm:
                  valuesObject:
                    provider:   ${schema.spec.dns.providers.builtin.provider}
                    email:      ${schema.spec.dns.providers.builtin.email}
                    domain:     ${schema.spec.dns.providers.builtin.domain}




      - id: certManagerDuckDnsWebhook
        includeWhen:
          - ${schema.spec.dns.providers.duckdns.enabled} # Only include if the user wants to use DuckDNS
        # readyWhen:
        #   - ${certManagerDuckDnsWebhook.status.state == "Ready"} # Ensure cert-manager is ready before deploying the webhook
        template:
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: cert-manager-duckdns-webhook
              namespace: argocd
              annotations:
                # argocd.argoproj.io/sync-wave: "0"
                argocd.argoproj.io/instance: cert-manager-bundle

              finalizers:
                - resources-finalizer.argocd.argoproj.io/foreground
              labels:
                  app.kubernetes.io/name:       cert-manager-duckdns-webhook-application
                  app.kubernetes.io/instance:   cert-manager-bundle
                  app.kubernetes.io/component:  cert-manager-duckdns-webhook
                  app.kubernetes.io/part-of:    mikrolab
            spec:
              project: default

              syncPolicy:
                automated:
                  selfHeal: true
                  prune: true
                  allowEmpty: true
              
                syncOptions:
                  - CreateNamespace=true
                  # - ApplyOutOfSyncOnly=true

              destination:
                server: https://kubernetes.default.svc
                namespace: cert-manager

              source:
                repoURL: https://csp33.github.io/cert-manager-duckdns-webhook
                chart: cert-manager-duckdns-webhook  
                targetRevision: 1.1.3
                helm:
                  valuesObject:
                    crds:
                      enabled: true
                      keep: false

                    groupName: 'acme.${schema.spec.dns.providers.duckdns.domain}-acme'

                    fullnameOverride: "cert-manager-duckdns-webook"

                    clusterIssuer:
                      email: ${schema.spec.dns.providers.duckdns.email}

                      ## A defect in this chart prevents the staging issuer from being created if production is enabled.
                      production:
                        create: true
                        server: https://acme-v02.api.letsencrypt.org/directory
                        name: duckdns-letsencrypt-prod
                      staging:
                        create: true
                        server: https://acme-staging-v02.api.letsencrypt.org/directory
                        name: duckdns-letsencrypt-staging
            
                    token:
                      existingSecret: true
                      existingSecretName: duckdns-api-key-secret

      - id: duckdnsddns 
        includeWhen:
          - ${schema.spec.dns.providers.duckdns.dynamic} # Only include if the user wants to use dynamic DNS
        template:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: duckdns-ddns
            namespace: argocd
            annotations:
              argocd.argoproj.io/instance: cert-manager-bundle
              # argocd.argoproj.io/sync-wave: "-10"
              # argocd.argoproj.io/hook: "PreSync"
              
            finalizers:
              - resources-finalizer.argocd.argoproj.io/foreground
            labels:
                app.kubernetes.io/name:       duckdns-ddns-application
                app.kubernetes.io/instance:   cert-manager-bundle
                app.kubernetes.io/component:  duckdns-ddns
                app.kubernetes.io/part-of:    mikrolab
          spec:
            project: default

            syncPolicy:
              automated:
                selfHeal: true
                prune: true
                allowEmpty: true
            
              syncOptions:
                - CreateNamespace=true
                # - ApplyOutOfSyncOnly=true

            destination:
              server: https://kubernetes.default.svc
              namespace: cert-manager

            source:
              repoURL: git@github.com:rbellius/charts.git
              path: duckdns-ddns
              targetRevision: main
              helm:
                valuesObject:
                  domain: ${schema.spec.dns.providers.duckdns.domain}
                  schedule: "0-59/5 * * * *"
                  secret:

                    name: duckdns-api-key-secret
                    key: token

                  getIpCommand: kubectl -n kube-system get svc traefik -o jsonpath='{.status.loadBalancer.ingress[0].ip}'



## create optional "install" specs that add the applications for certain dependanies. ingress.install: true   | maybe ingressRequest.install:class
    
      # - id: ingressRequest
      #   includeWhen:
      #     - ${schema.spec.ingress.requests}
      #   template:
      #     apiVersion: argoproj.io/v1alpha1
      #     kind: Application
      #     metadata:
      #       name: ingress-request
      #       namespace: argocd
      #       annotations:
      #         argocd.argoproj.io/instance: cert-manager-bundle
              
      #       finalizers:
      #         - resources-finalizer.argocd.argoproj.io

      #     spec:
      #       project: default

      #       syncPolicy:
      #         automated:
      #           selfHeal: true
      #           prune: true
      #           allowEmpty: true
            
      #         syncOptions:
      #           - CreateNamespace=true
      #           # - ApplyOutOfSyncOnly=true

      #       destination:
      #         server: https://kubernetes.default.svc
      #         namespace: cert-manager

      #       source:
      #         repoURL: git@github.com:rbellius/resourcegraphdefinitions.git
      #         path: ingress-request-rgd
      #         targetRevision: main
      #         # helm:
              #   valuesObject:
