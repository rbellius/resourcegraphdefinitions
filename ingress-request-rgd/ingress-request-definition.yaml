apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: ingress-request-definition
  annotations:
    argocd.argoproj.io/instance: ingress-request-definition
  labels:
    app.kubernetes.io/name: ingress-request
    app.kubernetes.io/instance: ingress-request
    app.kubernetes.io/component: rgd
    app.kubernetes.io/part-of: mikrolab
    app.kubernetes.io/managed-by: argocd ## will this be tracked my argocd?
spec:
  schema:
    apiVersion: v1alpha1
    kind: IngressRequest
    spec:
   
      env: string | default="staging" enum="staging,production"
      subdomain: string

      service:
        name: string
        port: integer | default=80

    


  resources:

    # - id: certManagerBundle
    #   externalRef:
    #     apiVersion: kro.run/v1alpha1
    #     kind: CertManangerBundle
    #     metadata:
    #       name: cert-manager-bundle
    #       namespace: cert-manager
    #       # annotations:
    #       #   cert-manager.io/cluster-issuer: '${schema.spec.dnsProvider}-letsencrypt-${schema.spec.env}'


    - id: ingressConfig
      externalRef:
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: ingress-request-configmap
          namespace: cert-manager



    - id: ingressGenerator
      includeWhen:
        - ${ingressConfig.status.state == "Ready" && ingressConfig.data.?ingressClass == "traefik"}
      template:
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: ${schema.metadata.name}
          namespace: ${schema.metadata.namespace}
          annotations:
            cert-manager.io/cluster-issuer: ${ingressConfig.data.?clusterIssuer}
            argocd.argoproj.io/instance: ${schema.metadata.name}-${schema.metadata.namespace}-ingress-request
          # finalizers:
          #   - resources-finalizer.argocd.argoproj.io
            
          labels:
            app.kubernetes.io/instance: ${schema.metadata.name}
            app.kubernetes.io/name: ingress
            app.kubernetes.io/component: ingress
            app.kubernetes.io/part-of: ${schema.metadata.namespace}
            # app.kubernetes.io/managed-by: kro


        spec: 
          # ingressClassName: ${certManagerBundle.spec.ingress.class}
          ingressClassName: ${ingressConfig.data.?ingressClass}

      
          tls:
          - secretName: ${schema.metadata.name}-${schema.metadata.namespace}-${schema.spec.env}-tls
            hosts:
              - '${schema.spec.subdomain}.${ingressConfig.data.?domain}'

          rules:
          - host: '${schema.spec.subdomain}.${ingressConfig.data.?domain}'
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: ${schema.spec.service.name}
                    port:
                      number: ${schema.spec.service.port}

    #   ## Eliminate duplicate if CEL expressions allow the dynamic chaining for property names of providers. Otherwise we would need iterable loops or conditional gates within the spec
    # - id: ingressDuckdns
    #   includeWhen:
    #     - ${schema.spec.providers.duckdns}

    #   template:
    #     apiVersion: networking.k8s.io/v1
    #     kind: Ingress
    #     metadata:
    #       name: ${schema.metadata.name}
    #       annotations:
    #         cert-manager.io/cluster-issuer: ${ingressConfig.data.?clusterIssuer}
    #       finalizers:
    #           # - resources-finalizer.argocd.argoproj.io

    #       labels:
    #         app.kubernetes.io/instance: ${schema.metadata.name}
    #         app.kubernetes.io/name: ingress
    #         app.kubernetes.io/component: ingress
    #         app.kubernetes.io/part-of: ${schema.metadata.namespace}
    #         # app.kubernetes.io/managed-by: kro


    #     spec: 
    #       ingressClassName: ${ingressConfig.data.?ingressClass}

      
    #       tls:
    #       - secretName: ${schema.metadata.name}-${schema.metadata.namespace}-${schema.spec.env}-tls
    #         hosts:
    #           - '${schema.spec.subdomain}.${ingressConfig.data.?clusterIssuer}'

    #       rules:
    #       - host: '${schema.spec.subdomain}.${ingressConfig.data.?clusterIssuer}'
    #         http:
    #           paths:
    #           - path: /
    #             pathType: Prefix
    #             backend:
    #               service:
    #                 name: ${schema.spec.serviceName}
    #                 port:
    #                   number: ${schema.spec.servicePort}